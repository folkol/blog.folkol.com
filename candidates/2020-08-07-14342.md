programming language tokenisation:

either tokenize / parse / bind, OR we can add tokens by a = 2, and then aa2 means "a" "a" 2.

What about merging regexes instead of looping?


for pattern in patterns:
	if pattern ~ input:
		...

vs

pattern = U patterns

if pattern ~ input:
	...





Notes:
	"new note" must be extremely cheap (and global)
	"move note to notebook" can be done afterwards
	"taggning notes"
	"notes have parents" or "notes have tags / metadata"
	"notes can be text or images or formulas etc"
	"automatic tags when they are moved around"
	"scratch" vs "theme" (think of "current ticket" etc?)
	"easy to transfer physical notes to notebook" maybe image + transcription?
	"highlight notes"
	"link notes"
	"dates of add / update", history? Automatic add / commit in the background? Or on save?
	"autosave" adds history?

Sync with other computers? Maybe just keep in iCloud folder?



Given a LCG with unknown seed, the generated numbers give hints about the state of the LCG.
State: abcdefghijklmnopq...
	Generated numbers:
	k	k is state * foo % bar + filter.
	i
	j

LCG:s can be ran backwards (but fan out?).
The generated numbers also reduce the candidate space.

Unknown state N:
nextInt: n

Unknown state:
{0, 1} ** n

Each generated number fixes some of these, so after a few steps, it might look like this:

10010{01}{01}{01}{01}{01}{01}{01}{01}001{01}

Still many, but A LOT less.

What can we use this for?

Say that sessions did not use securenumbers, but these pseudonumbers?

startup: seed, maybe from time?
my session cookie: alksdfj
Generate a few more: asdofaos kjlashdfkljas aklshfhlkasdf
This might give hints about other session cookies.

We don't even need to have subsequent numbers, just that 'first N numbers' contain these.
