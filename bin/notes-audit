#!/usr/bin/env python3
"""
Notes audit CLI - Triage files in ~/Documents/notes for blog post candidates.

Usage:
    notes-audit review          # Review pending notes (default)
    notes-audit status          # Show statistics
    notes-audit reset [--all | --path PATH]  # Reset decisions
    notes-audit unreject --path PATH  # Clear rejection for a note
    notes-audit list [rejected|accepted|idea]  # List decisions
"""

import argparse
import hashlib
import json
import os
import re
import signal
import subprocess
import sys
import termios
import tty
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Configuration
NOTES_DIR = Path.home() / "Documents" / "notes"
BLOG_ROOT = Path(__file__).parent.parent
CANDIDATES_DIR = BLOG_ROOT / "candidates"
STATE_DIR = BLOG_ROOT / ".notes-audit"
STATE_FILE = STATE_DIR / "state.json"
REJECTED_LOG = STATE_DIR / "rejected.jsonl"
ACCEPTED_LOG = STATE_DIR / "accepted.jsonl"

# Binary extensions to skip
BINARY_EXTENSIONS = {
    ".png", ".jpg", ".jpeg", ".gif", ".webp", ".pdf", ".zip", ".tar", ".gz",
    ".bz2", ".xz", ".mp4", ".mp3", ".avi", ".mov", ".webm", ".ico", ".svg",
    ".woff", ".woff2", ".ttf", ".otf", ".eot", ".exe", ".dmg", ".pkg",
    ".deb", ".rpm", ".apk", ".bin", ".so", ".dylib", ".dll"
}

# Summary preview size
SUMMARY_PREVIEW_LINES = 30
SUMMARY_PREVIEW_CHARS = 3000


def ensure_state_dir():
    """Create state directory if it doesn't exist."""
    STATE_DIR.mkdir(exist_ok=True)
    if not STATE_FILE.exists():
        with open(STATE_FILE, "w") as f:
            json.dump({}, f)


def load_state() -> Dict:
    """Load state from JSON file."""
    ensure_state_dir()
    if not STATE_FILE.exists():
        return {}
    try:
        with open(STATE_FILE, "r") as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {}


def save_state(state: Dict):
    """Save state to JSON file."""
    ensure_state_dir()
    with open(STATE_FILE, "w") as f:
        json.dump(state, f, indent=2)


def append_log(log_file: Path, entry: Dict):
    """Append entry to JSONL log file."""
    ensure_state_dir()
    with open(log_file, "a") as f:
        f.write(json.dumps(entry) + "\n")


def compute_fingerprint(file_path: Path) -> Tuple[int, int, str]:
    """Compute fingerprint: (mtime_ns, size, sha256)."""
    stat = file_path.stat()
    mtime_ns = stat.st_mtime_ns
    size = stat.st_size
    
    # Compute SHA256 only if needed (for change detection)
    sha256 = ""
    if size > 0:
        with open(file_path, "rb") as f:
            sha256 = hashlib.sha256(f.read()).hexdigest()
    
    return (mtime_ns, size, sha256)


def is_text_file(file_path: Path) -> bool:
    """Check if file is text-like."""
    # Skip binary extensions
    if file_path.suffix.lower() in BINARY_EXTENSIONS:
        return False
    
    # Check for NUL bytes in first chunk
    try:
        with open(file_path, "rb") as f:
            chunk = f.read(8192)
            if b"\x00" in chunk:
                return False
    except (IOError, OSError):
        return False
    
    return True


def scan_notes() -> List[Path]:
    """Recursively scan ~/Documents/notes for text files."""
    notes = []
    if not NOTES_DIR.exists():
        return notes
    
    for root, dirs, files in os.walk(NOTES_DIR):
        # Skip hidden directories
        dirs[:] = [d for d in dirs if not d.startswith(".")]
        
        for file in files:
            # Skip hidden files
            if file.startswith("."):
                continue
            
            file_path = Path(root) / file
            if file_path.is_file() and is_text_file(file_path):
                notes.append(file_path)
    
    return sorted(notes)


def get_file_summary(file_path: Path) -> Dict:
    """Generate summary for a file."""
    try:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            lines = f.readlines()
    except (IOError, OSError, UnicodeDecodeError):
        return {
            "title": file_path.name,
            "lines": 0,
            "words": 0,
            "preview": "",
            "headings": []
        }
    
    # Find first non-empty line as title
    title = file_path.name
    for line in lines:
        stripped = line.strip()
        if stripped:
            title = stripped[:80]
            break
    
    # Count words (approximate)
    words = sum(len(line.split()) for line in lines)
    
    # Extract headings (markdown-style)
    headings = []
    for line in lines[:50]:  # Check first 50 lines
        stripped = line.strip()
        if stripped.startswith("#"):
            headings.append(stripped[:80])
    
    # Preview: first N non-empty lines or first N chars
    preview_lines = []
    char_count = 0
    for line in lines:
        stripped = line.strip()
        if stripped:
            preview_lines.append(stripped)
            char_count += len(stripped)
            if len(preview_lines) >= SUMMARY_PREVIEW_LINES or char_count >= SUMMARY_PREVIEW_CHARS:
                break
    
    preview = "\n".join(preview_lines[:SUMMARY_PREVIEW_LINES])
    if char_count > SUMMARY_PREVIEW_CHARS:
        preview = preview[:SUMMARY_PREVIEW_CHARS] + "..."
    
    stat = file_path.stat()
    mtime = datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
    
    return {
        "title": title,
        "lines": len(lines),
        "words": words,
        "preview": preview,
        "headings": headings[:5],  # Limit to 5 headings
        "mtime": mtime,
        "size": stat.st_size
    }


def build_review_queue(state: Dict) -> List[Tuple[Path, Dict, Optional[str]]]:
    """Build queue of notes to review: (path, summary, last_decision)."""
    notes = scan_notes()
    queue = []
    
    for note_path in notes:
        abs_path = str(note_path.resolve())
        note_state = state.get(abs_path, {})
        
        # Compute current fingerprint
        mtime_ns, size, sha256 = compute_fingerprint(note_path)
        
        # Check if changed
        stored_mtime = note_state.get("mtime_ns")
        stored_size = note_state.get("size")
        stored_sha256 = note_state.get("sha256", "")
        
        changed = False
        if stored_mtime is None or stored_size is None:
            # New file
            changed = True
        elif stored_mtime != mtime_ns or stored_size != size:
            # mtime or size changed, check SHA256
            if stored_sha256 != sha256:
                changed = True
        
        status = note_state.get("status", "pending")
        
        # Include if pending, postponed, or changed
        # Note: "idea", "accepted", "rejected" are final statuses - only include if changed
        should_include = status in ("pending", "postponed") or changed
        
        if should_include:
            # If changed and was in a final status, reset to pending but keep history
            if changed and status in ("accepted", "rejected", "idea"):
                note_state["status"] = "pending"
                note_state["changed_since"] = True
            elif changed:
                note_state["changed_since"] = True
            else:
                note_state["changed_since"] = False
            
            # Update fingerprint
            note_state["mtime_ns"] = mtime_ns
            note_state["size"] = size
            note_state["sha256"] = sha256
            
            summary = get_file_summary(note_path)
            # Show previous decision if file was changed
            last_decision = status if changed and status in ("accepted", "rejected", "idea", "postponed") else None
            queue.append((note_path, summary, last_decision))
    
    # Sort: pending first, then postponed, then by mtime (newest first)
    def sort_key(item):
        path, summary, last_decision = item
        abs_path = str(path.resolve())
        note_state = state.get(abs_path, {})
        status = note_state.get("status", "pending")
        priority = {"pending": 0, "postponed": 1}.get(status, 2)
        mtime = path.stat().st_mtime
        return (priority, -mtime)
    
    queue.sort(key=sort_key)
    return queue


def format_date_prefix(mtime: float) -> str:
    """Format date prefix from mtime: YYYY-MM-DD-"""
    return datetime.fromtimestamp(mtime).strftime("%Y-%m-%d-")


def needs_date_prefix(filename: str) -> bool:
    """Check if filename already has YYYY-MM-DD- prefix."""
    return bool(re.match(r"^\d{4}-\d{2}-\d{2}-", filename))


def get_destination_path(source_path: Path) -> Path:
    """Determine destination path in candidates directory."""
    basename = source_path.name
    mtime = source_path.stat().st_mtime
    
    if needs_date_prefix(basename):
        dest_name = basename
    else:
        dest_name = format_date_prefix(mtime) + basename
    
    return CANDIDATES_DIR / dest_name


def find_available_path(dest_path: Path, source_path: Path) -> Path:
    """Find available path, adding -2, -3, etc. if needed."""
    if not dest_path.exists():
        return dest_path
    
    # Check if contents are identical
    try:
        with open(dest_path, "rb") as dest_file:
            dest_content = dest_file.read()
        with open(source_path, "rb") as source_file:
            source_content = source_file.read()
        if dest_content == source_content:
            # Contents identical, can use existing path
            return dest_path
    except (IOError, OSError):
        pass
    
    # If exists and different, find variant
    base = dest_path.stem
    suffix = dest_path.suffix
    parent = dest_path.parent
    counter = 2
    
    while True:
        variant = parent / f"{base}-{counter}{suffix}"
        if not variant.exists():
            return variant
        counter += 1


def accept_note(note_path: Path, state: Dict):
    """Accept a note: copy to candidates and update state."""
    abs_path = str(note_path.resolve())
    
    # Ensure candidates directory exists
    CANDIDATES_DIR.mkdir(exist_ok=True)
    
    # Determine destination
    dest_path = get_destination_path(note_path)
    dest_path = find_available_path(dest_path, note_path)
    
    # Copy file
    import shutil
    shutil.copy2(note_path, dest_path)
    
    # Update state
    note_state = state.get(abs_path, {})
    note_state["status"] = "accepted"
    note_state["dest_path"] = str(dest_path)
    mtime_ns, size, sha256 = compute_fingerprint(note_path)
    note_state["mtime_ns"] = mtime_ns
    note_state["size"] = size
    note_state["sha256"] = sha256
    state[abs_path] = note_state
    
    # Log acceptance
    append_log(ACCEPTED_LOG, {
        "timestamp": datetime.now().isoformat(),
        "source": abs_path,
        "dest": str(dest_path)
    })
    
    save_state(state)
    print(f"âœ“ Accepted: copied to {dest_path.relative_to(BLOG_ROOT)}")


def reject_note(note_path: Path, state: Dict):
    """Reject a note: mark as rejected and update state."""
    abs_path = str(note_path.resolve())
    
    # Update state
    note_state = state.get(abs_path, {})
    note_state["status"] = "rejected"
    mtime_ns, size, sha256 = compute_fingerprint(note_path)
    note_state["mtime_ns"] = mtime_ns
    note_state["size"] = size
    note_state["sha256"] = sha256
    state[abs_path] = note_state
    
    # Log rejection
    append_log(REJECTED_LOG, {
        "timestamp": datetime.now().isoformat(),
        "path": abs_path
    })
    
    save_state(state)
    print(f"âœ— Rejected: {note_path.name}")


def postpone_note(note_path: Path, state: Dict):
    """Postpone a note: mark as postponed."""
    abs_path = str(note_path.resolve())
    
    note_state = state.get(abs_path, {})
    note_state["status"] = "postponed"
    mtime_ns, size, sha256 = compute_fingerprint(note_path)
    note_state["mtime_ns"] = mtime_ns
    note_state["size"] = size
    note_state["sha256"] = sha256
    state[abs_path] = note_state
    
    save_state(state)
    print(f"âŠ˜ Postponed: {note_path.name}")


def mark_idea(note_path: Path, state: Dict):
    """Mark a note as 'good idea, but not a blog post'."""
    abs_path = str(note_path.resolve())
    
    note_state = state.get(abs_path, {})
    note_state["status"] = "idea"
    mtime_ns, size, sha256 = compute_fingerprint(note_path)
    note_state["mtime_ns"] = mtime_ns
    note_state["size"] = size
    note_state["sha256"] = sha256
    state[abs_path] = note_state
    
    # Log idea
    append_log(ACCEPTED_LOG, {
        "timestamp": datetime.now().isoformat(),
        "source": abs_path,
        "status": "idea"
    })
    
    save_state(state)
    print(f"ðŸ’¡ Idea (not blog post): {note_path.name}")


def clear_screen():
    """Clear the terminal screen."""
    os.system("clear" if os.name != "nt" else "cls")


def get_single_char():
    """Read a single character from stdin without requiring ENTER."""
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch


def review_notes():
    """Main review loop."""
    state = load_state()
    queue = build_review_queue(state)
    
    if not queue:
        print("No notes to review.")
        return
    
    print(f"\nFound {len(queue)} note(s) to review.\n")
    input("Press Enter to start...")
    
    i = 0  # Current index in queue
    while i < len(queue):
        note_path, summary, last_decision = queue[i]
        abs_path = str(note_path.resolve())
        rel_path = note_path.relative_to(NOTES_DIR)
        
        clear_screen()
        print("=" * 80)
        print(f"Note {i+1}/{len(queue)}: {rel_path}")
        print("=" * 80)
        
        if last_decision:
            print(f"Previous decision: {last_decision} (file was updated)")
        print(f"Modified: {summary['mtime']}")
        print(f"Size: {summary['size']:,} bytes, {summary['lines']} lines, ~{summary['words']} words")
        
        if summary['headings']:
            print("\nHeadings:")
            for heading in summary['headings']:
                print(f"  {heading}")
        
        print(f"\nPreview:\n{summary['preview']}\n")
        print("-" * 80)
        
        # Prompt for action (single keypress)
        while True:
            back_prompt = " (b)ack" if i > 0 else ""
            print(f"Action: (a)ccept (r)eject (i)dea (p)ostpone (o)pen{back_prompt} (s)kip (h)elp (q)uit: ", end="", flush=True)
            action = get_single_char().lower()
            print(action)  # Echo the character and newline
            
            if action == "a":
                clear_screen()
                accept_note(note_path, state)
                state = load_state()  # Reload in case of concurrent changes
                i += 1  # Move to next file
                break
            elif action == "r":
                clear_screen()
                reject_note(note_path, state)
                state = load_state()
                i += 1  # Move to next file
                break
            elif action == "i":
                clear_screen()
                mark_idea(note_path, state)
                state = load_state()
                i += 1  # Move to next file
                break
            elif action == "p":
                clear_screen()
                postpone_note(note_path, state)
                state = load_state()
                i += 1  # Move to next file
                break
            elif action == "o":
                # Open file in less
                # Terminal is already in normal mode after get_single_char() returns
                # Temporarily ignore SIGINT so Ctrl+C only affects less, not the parent
                original_sigint = signal.signal(signal.SIGINT, signal.SIG_IGN)
                try:
                    subprocess.run(["less", str(note_path)], check=False)
                finally:
                    # Restore original SIGINT handler
                    signal.signal(signal.SIGINT, original_sigint)
                clear_screen()
                # Re-display the note info
                print("=" * 80)
                print(f"Note {i+1}/{len(queue)}: {rel_path}")
                print("=" * 80)
                if last_decision:
                    print(f"Previous decision: {last_decision} (file was updated)")
                print(f"Modified: {summary['mtime']}")
                print(f"Size: {summary['size']:,} bytes, {summary['lines']} lines, ~{summary['words']} words")
                if summary['headings']:
                    print("\nHeadings:")
                    for heading in summary['headings']:
                        print(f"  {heading}")
                print(f"\nPreview:\n{summary['preview']}\n")
                print("-" * 80)
                continue  # Continue to show prompt again
            elif action == "b":
                # Go back to previous file
                if i > 0:
                    i -= 1
                    break  # Break inner loop to re-display previous file
                else:
                    print("Already at first file.")
                    continue
            elif action == "s":
                clear_screen()
                print("Skipped.")
                i += 1  # Move to next file
                break
            elif action == "h":
                # Show help
                clear_screen()
                print("=" * 80)
                print("Help - Command Descriptions")
                print("=" * 80)
                print("  (a)ccept  - Copy note to candidates directory as blog post")
                print("  (r)eject  - Mark note as rejected (won't appear again unless changed)")
                print("  (i)dea    - Mark as good idea but not a blog post")
                print("  (p)ostpone - Mark for later review (appears in future sessions)")
                print("  (o)pen    - Open full file in less for inspection")
                if i > 0:
                    print("  (b)ack    - Go back to previous file")
                print("  (s)kip    - Skip without making a decision (remains pending)")
                print("  (h)elp    - Show this help message")
                print("  (q)uit    - Exit the review session")
                print("=" * 80)
                input("\nPress Enter to continue...")
                clear_screen()
                # Re-display the note info
                print("=" * 80)
                print(f"Note {i+1}/{len(queue)}: {rel_path}")
                print("=" * 80)
                if last_decision:
                    print(f"Previous decision: {last_decision} (file was updated)")
                print(f"Modified: {summary['mtime']}")
                print(f"Size: {summary['size']:,} bytes, {summary['lines']} lines, ~{summary['words']} words")
                if summary['headings']:
                    print("\nHeadings:")
                    for heading in summary['headings']:
                        print(f"  {heading}")
                print(f"\nPreview:\n{summary['preview']}\n")
                print("-" * 80)
                continue  # Continue to show prompt again
            elif action == "q":
                clear_screen()
                print("Quitting.")
                return
            else:
                print("Invalid action. Use: a, r, i, p, o, b, s, h, or q")


def show_status():
    """Show statistics about notes."""
    state = load_state()
    notes = scan_notes()
    
    counts = {
        "pending": 0,
        "postponed": 0,
        "accepted": 0,
        "rejected": 0,
        "idea": 0,
        "changed": 0,
        "total": len(notes)
    }
    
    for note_path in notes:
        abs_path = str(note_path.resolve())
        note_state = state.get(abs_path, {})
        status = note_state.get("status", "pending")
        
        if status in counts:
            counts[status] += 1
        
        # Check if changed
        mtime_ns, size, sha256 = compute_fingerprint(note_path)
        stored_mtime = note_state.get("mtime_ns")
        stored_size = note_state.get("size")
        
        if stored_mtime is not None and stored_size is not None:
            if stored_mtime != mtime_ns or stored_size != size:
                counts["changed"] += 1
    
    print("\nNotes Audit Status")
    print("=" * 40)
    print(f"Total notes:        {counts['total']}")
    print(f"Pending review:     {counts['pending']}")
    print(f"Postponed:          {counts['postponed']}")
    print(f"Accepted:           {counts['accepted']}")
    print(f"Rejected:           {counts['rejected']}")
    print(f"Idea (not post):    {counts['idea']}")
    print(f"Changed since last: {counts['changed']}")
    print()


def reset_decisions(all_files: bool = False, path: Optional[str] = None):
    """Reset decisions for notes."""
    state = load_state()
    
    if all_files:
        # Reset all
        for abs_path in list(state.keys()):
            note_state = state[abs_path]
            if note_state.get("status") != "pending":
                note_state["status"] = "pending"
        print("Reset all decisions.")
    elif path:
        # Reset specific path
        target_path = Path(path).resolve()
        abs_path = str(target_path)
        if abs_path in state:
            state[abs_path]["status"] = "pending"
            print(f"Reset decision for: {path}")
        else:
            print(f"Note not found in state: {path}")
    else:
        print("Error: specify --all or --path")
        return
    
    save_state(state)


def unreject_note(path: str):
    """Clear rejection for a specific note."""
    state = load_state()
    target_path = Path(path).resolve()
    abs_path = str(target_path)
    
    if abs_path in state:
        note_state = state[abs_path]
        if note_state.get("status") == "rejected":
            note_state["status"] = "pending"
            save_state(state)
            print(f"Cleared rejection for: {path}")
        else:
            print(f"Note is not rejected: {path}")
    else:
        print(f"Note not found in state: {path}")


def list_decisions(category: str):
    """List accepted, rejected, or idea notes."""
    state = load_state()
    
    if category not in ("accepted", "rejected", "idea"):
        print("Error: category must be 'accepted', 'rejected', or 'idea'")
        return
    
    matches = []
    for abs_path, note_state in state.items():
        if note_state.get("status") == category:
            note_path = Path(abs_path)
            try:
                rel_path = note_path.relative_to(NOTES_DIR)
            except ValueError:
                rel_path = note_path
            matches.append((rel_path, note_state))
    
    if not matches:
        print(f"No {category} notes found.")
        return
    
    print(f"\n{category.capitalize()} notes ({len(matches)}):")
    print("=" * 80)
    for rel_path, note_state in sorted(matches):
        print(f"  {rel_path}")
        if category == "accepted" and "dest_path" in note_state:
            dest = Path(note_state["dest_path"]).relative_to(BLOG_ROOT)
            print(f"    â†’ {dest}")
    print()


def main():
    parser = argparse.ArgumentParser(
        description="Triage notes for blog post candidates",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Command")
    
    # review command (default)
    review_parser = subparsers.add_parser("review", help="Review pending notes (default)")
    
    # status command
    status_parser = subparsers.add_parser("status", help="Show statistics")
    
    # reset command
    reset_parser = subparsers.add_parser("reset", help="Reset decisions")
    reset_group = reset_parser.add_mutually_exclusive_group(required=True)
    reset_group.add_argument("--all", action="store_true", help="Reset all decisions")
    reset_group.add_argument("--path", help="Reset decision for specific path")
    
    # unreject command
    unreject_parser = subparsers.add_parser("unreject", help="Clear rejection for a note")
    unreject_parser.add_argument("--path", required=True, help="Path to note")
    
    # list command
    list_parser = subparsers.add_parser("list", help="List accepted, rejected, or idea notes")
    list_parser.add_argument("category", choices=["accepted", "rejected", "idea"], help="Category to list")
    
    args = parser.parse_args()
    
    # Default to review if no command
    command = args.command or "review"
    
    if command == "review":
        review_notes()
    elif command == "status":
        show_status()
    elif command == "reset":
        reset_decisions(all_files=args.all, path=args.path)
    elif command == "unreject":
        unreject_note(args.path)
    elif command == "list":
        list_decisions(args.category)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
